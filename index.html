<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Professional Portfolio</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Nunito Sans', sans-serif;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #f4f4f4;
        }
        header {
            background: #0056b3;
            color: #fff;
            padding: 20px 40px;
            text-align: center;
        }
        header h1 {
            margin: 0;
        }
        nav {
            background: #03396c;
            text-align: center;
            padding: 10px 0;
        }
        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        nav ul li {
            display: inline;
            margin-right: 20px;
        }
        nav a {
            text-decoration: none;
            color: #fff;
            font-weight: 600;
        }
        nav a:hover {
            text-decoration: underline;
        }
        section {
            background: #fff;
            padding: 20px 40px;
            margin: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        footer {
            text-align: center;
            padding: 10px;
            background: #022b54;
            color: white;
        }
    </style>
</head>
<body>
    <header>
        <h1>Welcome to My Professional Portfolio</h1>
        <p>An overview of my skills and achievements in software development.</p>
    </header>
    <nav>
        <ul>
            <li><a href="#assessment">Professional Self-Assessment</a></li>
            <li><a href="#code-review">Code Review</a></li>
            <li><a href="#software-design">Software Design</a></li>
            <li><a href="#algorithms">Algorithms & Data Structures</a></li>
            <li><a href="#databases">Databases</a></li>
        </ul>
    </nav>
    <section id="assessment">
        <h2>Professional Self-Assessment</h2>
        <p>Professional Self-Assessment Journey
            As I navigate through my educational and professional development in computer science, I've focused intensively on honing my abilities in Android application development, while also nurturing a growing interest in UI design and cybersecurity. My journey has been shaped significantly by the dynamic and challenging nature of the field, which demands a deep understanding of both technical skills and user-centric design.
            
            In the realm of Android development, I've embraced the complexities of creating robust and user-friendly applications. A key project that exemplifies this was developing an inventory management app, which served as a practical application of my learning in software engineering. This project not only enhanced my coding skills but also deepened my appreciation for intuitive UI design—ensuring that the app was not only functional but also aesthetically pleasing and easy to navigate.
            
            Simultaneously, the critical importance of security in software development steered my aspirations towards cybersecurity. I've tackled numerous projects where the integration of secure coding practices was paramount. For example, implementing advanced security measures like SHA-256 password hashing and using secure APIs demonstrated the necessity of cybersecurity proficiency in protecting user data and ensuring the integrity of the software.
            
            My coursework has also been instrumental in preparing me for real-world scenarios, particularly in team collaboration and stakeholder communication. Working in diverse teams, I've taken on significant roles where my contributions in algorithm design and database management were crucial. These experiences not only improved my technical skills but also taught me the value of clear and effective communication, especially in projects involving complex technical details that needed to be conveyed to non-technical stakeholders.
            
            The development of my ePortfolio further solidified these experiences, allowing me to showcase my capabilities in a structured and impactful way. It highlighted not just my technical proficiency but also my ability to integrate user feedback into the development process, optimizing the user experience. This holistic approach to education and portfolio development has not only prepared me to enter the workforce but also to contribute meaningfully to discussions on software solutions, security protocols, and user interface enhancements.
            
            As I look forward to a career in either Android mobile development, UI design, or cybersecurity, I am excited by the opportunities to apply my skills in real-world applications. My aspirations include diving deeper into programming languages like C# and continuing to explore the vast landscape of cybersecurity. This journey through my computer science program has not only equipped me with a diverse set of skills but also shaped my professional values, emphasizing integrity, security, and the importance of user-centered design. Ready and eager, I am poised to join the workforce, bringing a strong foundation and a passionate commitment to advancing in the field of computer science.</p>
        <img src="path_to_your_image.jpg" alt="Professional Image">
    </section>
    <section id="code-review">
        <h2>Code Review</h2>
        <p>Add your text here and embed related videos.</p>
        <video width="100%" controls>
            <source src=""C:\Users\Jared\Documents\GitHub\JAtomsk.github.io\Code Review.mp4 type="video/mp4">
            Your browser does not support the video tag.
        </video>
        <h2>Software Design and Engineering</h2>
    <p>Here is the original version of my software design project:</p>
    <a href=https://github.com/JAtomsk/OriginalWarehouse>Original Code Repository</a>
    <p>Here is the enhanced version of my software design project, showcasing the improvements made:</p>
    <a href=https://github.com/JAtomsk/warehouse-inventory-app>Enhanced Code Repository</a>
    </section>
    <section id="software-design">
        <h2>Software Design and Engineering</h2>
        <p>Developed in Android Studio, the front end of the application features a basic layout optimized for mobile devices. It employs native Android components for listing inventory items and fragments for managing different application segments within a single activity. The application communicates with a SQLite database to perform CRUD operations on inventory items. The user interface is designed for fast navigation and effortless operation, with well-placed touch targets for interactions.
            1.	UI Theme and Color Update: Enhanced the visual appeal of the user interface by updating the theme and color scheme.
            2.	Custom Button Implementation: Integrated custom-designed buttons from Figma for performing CRUD operations, improving operational efficiency.
            3.	Enhanced Documentation: Added comprehensive comments to document the classes and fragments, facilitating easier development for any new developer.
            4.	User Account Creation Features: Implemented logic and UI components to enable username and password creation for user accounts.
            5.	Login Functionality and Feedback: Introduced logic and UI components for user login capabilities, complete with success or failure notifications.
            6.	Responsive UI Adjustments: Adjusted UI buttons and text fields to enhance responsiveness across different devices.
            7.	Quick Quantity Adjustment Buttons: Added increment and decrement buttons for quick modifications of item quantities.
            8.	Database Schema Enhancements for Inventory: Updated the database schema to more accurately store item names, IDs, and quantities.
            9.	User Credentials Storage: Revised the database schema to securely store user credentials.
            10.	Error Logging for Login: Incorporated error logging for tracking and debugging user login issues.
            11.	Secure Database Operations: Implemented prepared statements in database operations to enhance security and efficiency.
            12.	Enhanced Password Security: Added SHA-256 hashing for password storage and verification to ensure robust security.
            
            The skills showcased in this artifact highlight my ability to leverage well-founded and innovative techniques, tools, and skills in computing practices, aiming to implement computer solutions that deliver value and meet specific goals in Android mobile software development. The artifact features a thematic color theme designed to enhance visual engagement. These colors were meticulously chosen to be both pleasant and functional, providing a clear visual hierarchy and minimizing eye strain during prolonged usage.
            Custom buttons and user interface elements were crafted to efficiently handle essential CRUD (Create, Read, Update, Delete) operations within the app. Each button was designed in Figma to ensure it was not only visually appealing but also optimized for touch interactions on mobile devices. The branding of the JJWarehouse app is further reinforced through the design of an intuitive logo in vector format, maintaining sharpness across different screen resolutions.
            
            Text views and button listeners have been appropriately scaled to ensure they can be easily activated with a finger, thus eliminating the need for precise taps. Increment and decrement buttons were added to the item quantity fields, allowing users to quickly and efficiently adjust values, which is crucial for inventory management. Fonts and display elements were carefully selected and tested to ensure optimal readability on mobile screens, which helps reduce user errors and enhances the speed of inventory management tasks.
                The skills demonstrated in the software engineering and design of this inventory management application reflect a robust security mindset, crucial for anticipating and mitigating adversarial exploits within software architecture. This approach is vital in exposing potential vulnerabilities, mitigating design flaws, and ensuring the privacy and security of data and resources. Key to this strategy was the development and design of UI and logic to create, store, and verify user credentials to control access to the application. Initially, the app lacked mechanisms in the database schema for authenticating or verifying user identities, allowing unauthorized access at the simple press of a login button.
            
            To address this, a SHA-256 password hashing algorithm was implemented, leveraging its cryptographic strength to enhance security. This choice was pivotal in securing user passwords effectively, as it involved hashing passwords before storage and comparing hashed values during login attempts to prevent exposure of actual user passwords. This method was later upgraded to bcrypt in subsequent database enhancements, reflecting an ongoing commitment to adopting more robust security measures as the application evolved. At the time of these enhancements, the application continued to utilize a SQLite database, highlighting the adaptability of the system to incorporate advanced security features within existing database structures..
            
            Reflecting on the Software engineering and design enhancemnent.
            This enhancement initiated a transformative journey through complex paths of database and security improvements that reshaped the entire application. Reflecting on the process of enhancing and modifying this artifact has been an enlightening experience, albeit sometimes challenging and frustrating, but ultimately, incredibly rewarding. Initially, the application was vulnerable, lacking secure login functionality and essentially open to all. Addressing this fundamental flaw was my first order of business, leading to the implementation of a user registration feature. This not only enabled users to create unique usernames and passwords but also introduced me to the complexities of securely managing user credentials.
            
            A significant milestone was the transition from storing passwords in plain text to using SHA-256 hashing. This adjustment significantly bolstered the application's security posture by safeguarding user passwords. Moreover, incorporating prepared statements in database operations underscored the importance of defending the application against SQL injection attacks, a prevalent and potentially severe security threat.
            
            The journey toward these enhancements was far from direct. My initial lack of comprehensive technical knowledge necessitated a deep dive into various resources, tutorials, and documentation to properly understand and implement these features. A consistent challenge was maintaining the uniqueness of usernames within the application. Initially, I implemented a basic `addUser` method in the `DatabaseHelper` class, assuming it would be sufficient. However, it soon became apparent that without a system to verify existing usernames, duplicate entries could easily occur. Introducing a `checkUserExists` method addressed this issue by preventing the registration of duplicate usernames.
            
            Another hurdle involved updating the database schema to include user credentials. Despite having an `onUpgrade` method designed to manage schema changes, the persistence of user data was unpredictable. After thorough troubleshooting, a straightforward yet effective solution—uninstalling and reinstalling the application—resolved the issue, highlighting the need for a more robust method to manage database versions and upgrades.
            
            Initially, I anticipated that enhancing the UI would be the simpler and more enjoyable part of this process. Yet, delving into the intricacies of color theory, font choices, and deciding between vector or raster images for custom buttons proved just as challenging. Learning the appropriate scale and size of buttons through tools like Figma was a critical breakthrough for the design of the custom buttons. Comparing my UI's layout and design choices against other successful applications helped finalize decisions on font choices, scale, and button colors for this enhancement.
            .</p>
        <img src="path_to_your_image.jpg" alt="Software Design">
    </section>
    <section id="algorithms">
        <h2>Algorithms and Data Structures</h2>
        <p>Algorithms and Data Structures Enhancement :
            The inventory application utilizes a range of data structures and algorithms to manage operations such as the retrieval, insertion, update, and deletion of inventory items. These are implemented across both the front-end (Android app) and back-end systems, ensuring efficient data handling.
            Arrays and Lists: On the Android client, arrays and ArrayLists are used extensively to manage collections of inventory items. These structures are pivotal for storing data retrieved from the API and for displaying it within the UI, particularly in RecyclerViews, which are designed for efficient display of scrolling lists.
            Bundles: Bundles are employed to transfer data between fragments within the app. For instance, when an inventory item is selected, its details are encapsulated into a Bundle and transmitted to a detail view fragment. This method is integral for maintaining state and data continuity as users navigate through the application.
            Custom Objects: Object-oriented programming is leveraged to simplify data management through custom classes like Item, which includes fields such as id, name, and quantity. This approach encapsulates inventory data, facilitating more straightforward operations on individual items and enhancing code readability and maintainability.
            Query Processing: SQL queries are utilized to perform CRUD (Create, Read, Update, Delete) operations on the database. The performance of these queries is heavily influenced by factors such as the indexing of tables and the complexity of the queries themselves, highlighting the importance of efficient database design to overall application performance.
            
            Algorithms and Data Structures Enhancements Made
            The recent enhancements to the Inventory application, including the introduction of a search functionality and a user interface search bar, as well as updates to the Inventory Adapter, DataGridFragment, and DatabaseHelper classes, significantly showcase my adeptness in algorithms and data structures:
            Implementation of Search Functionality:
            •	Algorithms: The addition of a search bar necessitated the implementation of search algorithms within the DatabaseHelper class. The getItemsFilteredBy method employs SQL LIKE queries for partial string matching, a fundamental string searching algorithm.
            •	Data Structures: The Inventory Adapter manages dynamic data structures, such as an ArrayList of Item objects, facilitating real-time data manipulation and display. Updating this list in response to search queries illustrates proficient use of list operations, essential for effective data structure manipulation.
            UI Integration and Real-Time Data Interaction:
            •	Dynamic Data Binding: The RecyclerView within the DataGridFragment updates dynamically to display search results. This showcases efficient data binding from the data structures managed by the Inventory Adapter to the UI components, demonstrating the practical application of data structure principles in real scenarios.
            •	Efficient UI Updates: The Inventory Adapter's updateData method refreshes the RecyclerView when the dataset changes due to searches. This method exemplifies an effective application of the Adapter design pattern, reducing overhead and enhancing the app's responsiveness.
            Database Interaction Optimization:
            •	Optimized Data Fetching: The search functionality is supported by optimized SQL queries designed to fetch data efficiently, reducing response times and resource usage, which are critical for performance in database-driven Android applications.
            •	Reduced Time Complexity: By ensuring well-formed database queries that only fetch data as needed, the application minimizes the time associated with data retrieval operations, vital in environments where data volume can expand.
            Enhanced User Experience Through Responsive Design:
            •	Immediate Feedback: The real-time search feature provides immediate feedback to user inputs, a direct outcome of employing efficient algorithms and data structures to improve user experience.
            These enhancements not only elevate the functionality of the application but also highlight my skills in effectively integrating complex algorithms and data structures to enhance both the backend functionality and frontend user interaction.
            Improvement Impact:
            •	Scalability: The enhancements made allow the application to handle larger datasets, making it more scalable and stronger against performance decreases as the data grows.
            •	Maintainability: By clearly separating the concerns— assigning distinct roles to UI handling, data management, and database interactions—I have managed to enhance the maintainability of the code. This structure allows each component to be modified or upgraded.
            •	User Satisfaction: By adding and improving  the responsiveness  of the search functionality, the application can provide a smother user experience.
             These enhancements display my ability to apply algorithms and data structures and improve the usability and performance of the inventory application. These improvements are aligned with industry best practices and demonstrate an understanding of the  challenges involved in mobile app development.
            The skills demonstrated in this artifact illustrate my ability to design, develop, and effectively communicate professional-quality oral, written, and visual content that is coherent, technically sound, and suitably tailored for specific audiences and contexts. Through detailed narratives and inline comments within the DataGridFragment, InventoryAdapter, and DatabaseHelper classes, I provide clear and insightful descriptions of functionalities, explaining the rationale behind each decision and implementation. This effectively showcases my capability to articulate complex software functionalities and algorithms in a manner that is both clear and informative. Additionally, the implementation of a user-friendly search interface in the DataGridFragment, complete with responsive feedback mechanisms such as Toast messages and dynamic updates, underscores my skill in adapting visual communication to meet user needs—a critical aspect in professional software development where interface design directly influences user experience and satisfaction.
            The skills displayed in this artifact exemplify my ability to employ well-established and innovative techniques, tools, and methodologies in computing practices to develop solutions that deliver significant value and achieve goals specific to the industry.
            Algorithmic Thinking: The application of SQL LIKE queries for data searching and the dynamic management of data structures within the InventoryAdapter demonstrate effective data handling and presentation techniques. This design underscores a comprehensive understanding of software engineering principles.
            Best Practices: The enhancements showcase the application of best practices in database management and UI interactions. For instance, optimizing data retrieval from the SQLite database significantly reduces latency and enhances performance, illustrating my proficiency in using database management tools effectively.
            Industry Standards: The modifications I made are in line with current industry standards for mobile app development, specifically for Android platforms. The use of RecyclerView for efficient list management and a modular coding approach ensures scalability and adaptability of the application, reflecting an alignment with contemporary development practices.
            Meeting Industry-Specific Goals:
             Performance: By adding and optimizing the search and data retrieval functions, the application is better equipped to handle larger datasets, which is important for real-world applications involving inventory management.
                User-Oriented Design: The focus on improving user interaction through a responsive UI design makes sure  that the Inventory Management Application shows  value by enhancing user satisfaction and engagement, key goals in the Android Development career field.
            
            Reflecting on the Algorithms and Data Structures Enhancement
            Throughout the development of this project, I encountered numerous challenges and gained a wealth of knowledge in the process. Much of my implementation was built not from prior expertise but through diligent study and reference. I frequently consulted "Java Data Structures and Algorithms" by Daniele Liang, along with resources from the Zybooks Mobile Architecture class website. Java was not a language with which I was intimately familiar, yet it is currently the most relevant language for Android development, pushing me to deepen my understanding.
            One of the new features I introduced was the search functionality capable of handling real-time data filtering—a task I had never tackled before. Developing a search operation that was both quick and efficient required exploring SQLite queries designed to sift through large datasets without degrading performance. Before the final submission, I plan to populate the SQLite database with a larger volume of random inventory. Currently, the limited inventory I have inputted doesn't fully showcase the capabilities of this feature, underscoring the need for more comprehensive testing to demonstrate its effectiveness truly.
            The biggest problem faced was integrating the search functionality with the already existing recycler view. The Recyclerview had to be dynamically updated based on the search results. To achieve this, I had to take a number of approaches with data binding and adapter updates. Designing the RecyclerView in a way to be  updated in real time as users typed their search queries without lagging involved management of the adapter's data set and careful handling of state changes within the application.
                Maintaining consistency with the U.I. aesthetic posed some challenges. Particularly in introducing new elements like the search bar and sorting options. However, that does not directly apply to the enhancement theme of data structures and algorithms. This did require frequent revisions and refinements to align with best practices in UI design.
            </p>
        <img src="path_to_your_image.jpg" alt="Algorithms">
    </section>
    <section id="databases">
        <h2>Databases</h2>
        <p>Database Enhancement
            Before transitioning to a MySQL database, the JJWarehouse application used SQLite for local data management through the DatabaseHelper.java class. This class facilitated creating and managing the application's database, including user and inventory data. SQLite, embedded within Android applications, allowed for straightforward and efficient data operations directly on the device.
            
            The old DatabaseHelper class provided a full suite of CRUD operations. It managed user authentication by storing usernames and hashed passwords, ensuring basic security. The inventory management was handled through similar CRUD operations, allowing the application to add, retrieve, update, and delete inventory items as needed. Each inventory item was identified by a unique ID, with additional attributes like name and quantity stored in a structured format.
            
            For user authentication, the class included methods to add new users with hashed passwords and to verify login credentials by comparing hashed passwords stored in the database. This approach, while effective for smaller, standalone applications, lacked the robust security and scalability provided by server-based databases like MySQL, prompting the transition. The move to MySQL, coupled with bcrypt for hashing and JWT for session management, marked a significant enhancement in the application’s security and data management capabilities, aligning it more closely with industry standards and practices.
            
            Database Enhancement List:
            1.	Migrated away from SQLite database to AWS MySql Database
            2.	Added modern frameworks (Node.js, Express,CORS)
            3.	Implemented bcrypt for password hashing.
            4.	Implemented JSON Web Token for Secure Authentication
            5.	Redesgined Database Schema with introductiuon of Tables (Items, Users,) with colums for ids, name and quantities.
            6.	Began work on Role-Based Access Control.
            7.	Designed and implemented RESTful API Development server to manage all backend operations for the JJWarehouse inventory management application.
            8.	improved Error Handling and Validation.
            9.	Search Functionality adapted to new database.
            10.	UI/UX refinement to support new features.
            Classes and Methods Added for Enhancement:
            1.	ApiInterface:
            •	This interface was added to define all the server communication endpoints for the Retrofit HTTP client. It includes methods for user registration, login, adding, updating, and deleting inventory items, among others. This class plays a crucial role in defining how the app interacts with the backend API.
            2.	LoginResponse and UserResponse:
            •	These classes were developed to handle responses from the server during login and user registration processes. They encapsulate the success status, messages, and other relevant data like tokens or user IDs returned by the server.
            3.	ItemResponse and ItemsResponse:
            •	Similar to LoginResponse, these classes are designed to handle responses related to inventory items from the server. ItemResponse deals with responses for single item operations, while ItemsResponse manages responses for requests that involve multiple items, such as fetching the entire inventory.
            4.	RetrofitClient:
            •	This class creates and configures the Retrofit instance used throughout the app to make network requests. It ensures that there is a single, reusable instance of Retrofit that includes all necessary configurations, such as the base URL and Gson converter for JSON parsing.
            5.	SharedPreferenceManager:
            •	Introduced to manage shared preferences, specifically for storing and retrieving JWT tokens and user roles locally on the device. This class is crucial for session management and ensuring that user credentials are handled securely.
            The skills for this artifact show that I have a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources by completing the following enhancements by transition from a local SQLite database to a robust MySQL database, paired with a secure server-side environment. This change not only modernized the data management practices but also significantly bolstered the security posture of the application. The implementation of these enhancements demonstrates a proactive security mindset, crucial for anticipating and mitigating potential adversarial exploits within software architectures. By integrating bcrypt for password hashing, the application now securely stores user credentials, thwarting potential attack vectors such as password cracking or brute force attacks. This method provides a strong defense against common vulnerabilities by ensuring that even if data breaches occur, the hashed passwords remain extremely difficult to decrypt.
                The adoption of JWT (JSON Web Token) for session management enhances the security and integrity of user sessions. JWTs are used to create a secure and stateless method of authentication, which is critical for protecting sessions from session hijacking and other forms of token theft. This approach to security is particularly vital in a mobile context where sessions may traverse insecure networks. Privacy is further protected through the use of HTTPS connections between the mobile app and the server, ensuring that all data transmitted is encrypted. This protects against interception and unauthorized access to sensitive information during transit, a common vulnerability in mobile applications.
            The skills in this artifact show my ability to design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices by effectively handling data retrieval in the fetch and filter data methods, incorporating considerations of Big O notation to optimize performance. Specifically, the fetchData and filterData methods in the DataGridFragment are designed to retrieve inventory items from the server efficiently. These methods use REST API calls facilitated by Retrofit to interact with a MySQL database, ensuring that data retrieval is both swift and scales well with increasing data sizes.
            In terms of Big O notation, the complexity of retrieving data can be considered O(n) where n is the number of items retrieved; however, the actual performance impact is mitigated by the use of proper indexing in the database and the efficient handling of JSON data through Gson serialization/deserialization in Retrofit. This means that while the worst-case scenario involves linear time complexity relative to the number of items, practical performance is enhanced by these technological choices.
            The filterData method further exemplifies efficient algorithmic implementation. It leverages SQL's LIKE query, which can be optimized with indices to reduce the search space significantly. When a user inputs a search term, the method constructs a query that efficiently filters through item names using partial matches. This approach, while potentially O(n) in cases where many items match the search pattern, typically performs better due to database optimizations and the selective nature of user queries.
            Additionally, these methods reflect a thoughtful trade-off between complexity and usability. By delegating heavy lifting to the server and minimizing data processing on the client side, the app maintains responsiveness and scalability. This is crucial in mobile applications where resource constraints are more pronounced.
            Overall, the integration of these methods within the application's architecture demonstrates a sophisticated understanding of how to apply computer science principles in practical, real-world applications. This not only solves the immediate problem of efficient data access but also aligns with broader industry standards that prioritize security, performance, and maintainability.
            
            The skills in this artifact demonstrate my ability to employ strategies for building collaborative environments that enable diverse audiences to support organizational decision-making in the field of computer science by designing an application that integrates user feedback and interactive features that cater to a wide range of users. The development of the inventory application, from its user interface to its backend services, illustrates a commitment to creating tools that are not only functional but also accessible and user-friendly.
            
            Firstly, the application's user interface is designed with simplicity and clarity in mind, making it easy for users of all skill levels to navigate and utilize its features effectively. This inclusivity fosters a collaborative environment where users feel comfortable interacting with the technology, regardless of their technical background. By ensuring that the interface is intuitive, the application encourages more users to engage with the system, thereby supporting broader organizational goals such as efficient inventory management and data accuracy.
            
            Secondly, the application supports decision-making by providing real-time data insights through its inventory management features. Users can add, update, delete, and search for items, allowing them to manage inventory efficiently and make informed decisions based on current inventory levels and requirements. This functionality is critical in organizational contexts where timely and accurate information is essential for operational success.
            
            Moreover, the application's backend, developed with secure API interactions and database management, ensures that user data is handled securely and efficiently, promoting trust among users. The shift from a SQLite database to a more robust MySQL setup with encrypted connections and secure token-based authentication demonstrates a strategic approach to security, crucial for collaborative environments where data integrity and privacy are paramount.
            
            Additionally, by employing tools and frameworks like Retrofit for network calls, Gson for JSON serialization, and clear API definitions, the project aligns with professional standards and practices in software development. These choices not only enhance the technical robustness of the application but also its maintainability and scalability, crucial aspects that support organizational decision-making as needs and technologies evolve.
            
            In summary, through thoughtful interface design, robust data handling, and adherence to security best practices, this project exemplifies how technological solutions can be crafted to support collaborative environments and aid diverse audiences in making informed decisions within the realm of computer science.
            
            Reflection on Database Enhancement
            This enhancement journey, while being the most challenging I've faced, has also been extraordinarily rewarding. Initially, I underestimated the complexity involved, and the project brought me face-to-face with many new concepts. My limited prior knowledge was both a hurdle and a catalyst for deep learning. While there's a nagging fear that my incomplete work might negatively impact my grade, the educational gains I've made are irreplaceable. This project introduced me to several firsts, including the challenge of setting up a MySQL database and securing a free service for it.
            After thorough research and numerous YouTube tutorials, I successfully established a MySQL database on a free Amazon account. The next phase involved creating the database schema using DataGrip via IntelliJ to access AWS. Adding a new column for user_roles was straightforward, but accessing the database through my Android emulator posed significant security risks if I had modified the manifest directly. Committed to maintaining high security standards, I opted to develop an API.
            For the API, I selected Node.js, a popular choice among Android developers that's also free. During the API development, I discovered that the SHA-256 password hashing technique I had been using was outdated. Learning to implement bcrypt, now considered the industry standard, was challenging due to my unfamiliarity with JavaScript. Securing the password hashing was just the beginning; I then implemented JSON Web Tokens (JWT) to manage roles within the app, aligning with industry standards for mobile applications using Role-Based Access Control (RBAC). This process involved updating user roles, re-login procedures, token issuance, JWT creation, and token usage, facilitating admin-level access where necessary.
            With the CRUD methods configured in my apiServer.json file, I felt close to completion. However, I soon faced the dilemma of how developers test APIs without a dedicated platform, which led me to discover Postman—an API testing tool that proved to be exactly what I needed. Testing methods in Postman was straightforward, such as adding a new inventory item with a POST request.
            Despite these significant strides in learning and development, I am still unsure if these efforts qualify as a full enhancement since they have yet to be successfully integrated into my Android application. My attempts to deploy the API using Beanstalk were unsuccessful, leaving the application unable to fully function with the new database setup. Although this exploration into API creation and deployment remains incomplete, it has been incredibly informative and will undoubtedly enhance my capability for future projects.
            </p>
        <img src="path_to_your_image.jpg" alt="Databases">
    </section>
    <footer>
        <p>© 2024 Your Name. All rights reserved.</p>
    </footer>
</body>
</html>
